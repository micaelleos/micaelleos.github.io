name: Sync Notion to Jekyll

on:
  # Roda a cada hora
  schedule:
    - cron: '0 * * * *'
  
  # Permite rodar manualmente
  workflow_dispatch:

jobs:
  sync:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Install dependencies
        run: |
          npm install notion-to-md @notionhq/client dotenv
      
      - name: Create sync script
        run: |
          cat > sync-notion.js << 'SCRIPT_EOF'
          const { Client } = require('@notionhq/client');
          const { NotionToMarkdown } = require('notion-to-md');
          const fs = require('fs');
          const path = require('path');

          const notion = new Client({ auth: process.env.NOTION_TOKEN });
          const n2m = new NotionToMarkdown({ notionClient: notion });

          function sanitizeSlug(text) {
            return String(text || '')
              .toLowerCase()
              .replace(/[^\w\s-]/g, '')
              .replace(/[\s_]+/g, '-')
              .replace(/-+/g, '-')
              .replace(/^-+|-+$/g, '');
          }

          async function downloadImage(url, folder) {
            try {
              await fs.promises.mkdir(folder, { recursive: true });
              const parsed = new URL(url);
              let filename = path.basename(parsed.pathname).split('?')[0];
              if (!filename.includes('.')) filename += '.jpg';
              const filepath = path.join(folder, filename);
              const res = await fetch(url);
              if (!res.ok) throw new Error(`Image download failed ${res.status}`);
              const arrayBuffer = await res.arrayBuffer();
              await fs.promises.writeFile(filepath, Buffer.from(arrayBuffer));
              return filepath;
            } catch (err) {
              console.warn('Failed to download image', err.message || err);
              return null;
            }
          }

          async function queryDatabase(databaseId, body) {
            if (notion.databases && typeof notion.databases.query === 'function') {
              return await notion.databases.query(Object.assign({ database_id: databaseId }, body));
            }
            console.warn('notion.databases.query not available; using fallback fetch to Notion API');
            const url = `https://api.notion.com/v1/databases/${databaseId}/query`;
            const res = await fetch(url, {
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${process.env.NOTION_TOKEN}`,
                'Notion-Version': '2022-06-28',
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(body || {})
            });
            const data = await res.json();
            if (!res.ok) {
              const err = new Error(`Notion API error: ${data.message || res.statusText}`);
              err.response = data;
              throw err;
            }
            return data;
          }

          async function syncPosts() {
            try {
              const filter = {
                filter: {
                  property: 'Published',
                  checkbox: { equals: true }
                }
              };

              const response = await queryDatabase(process.env.NOTION_DATABASE_ID, filter);
              console.log(`Found ${response.results?.length || 0} published posts`);

              const postsDir = path.join(process.cwd(), '_posts');
              if (!fs.existsSync(postsDir)) fs.mkdirSync(postsDir, { recursive: true });

              for (const page of (response.results || [])) {
                const pageId = page.id;
                const title = page.properties?.Title?.title?.[0]?.plain_text || page.properties?.Name?.title?.[0]?.plain_text || 'Untitled';
                let slug = page.properties?.Slug?.rich_text?.[0]?.plain_text || '';
                if (!slug) slug = sanitizeSlug(title);
                const rawDate = page.properties?.Date?.date?.start || new Date().toISOString();
                const datePrefix = rawDate.split('T')[0];
                const tags = page.properties?.Tags?.multi_select?.map(t => t.name) || [];
                const category = page.properties?.Category?.select?.name || '';
                const info = (page.properties?.Info?.rich_text?.[0]?.plain_text) || (page.properties?.Description?.rich_text?.[0]?.plain_text) || '';
                const tech = (page.properties?.Tech?.rich_text?.[0]?.plain_text) || page.properties?.Tech?.select?.name || '';

                // Try to find image: cover > property Image (files/url) > page.properties.Image.url
                let imageUrl = null;
                if (page.cover) imageUrl = page.cover.external?.url || page.cover.file?.url || imageUrl;
                const imgProp = page.properties?.Image;
                if (imgProp) {
                  if (imgProp.type === 'files' && imgProp.files && imgProp.files[0]) {
                    imageUrl = imgProp.files[0].file?.url || imgProp.files[0].external?.url || imageUrl;
                  } else if (imgProp.type === 'url') {
                    imageUrl = imgProp.url || imageUrl;
                  } else if (imgProp.type === 'rich_text') {
                    imageUrl = imgProp.rich_text?.[0]?.plain_text || imageUrl;
                  }
                }

                // Download image if available
                let imageFront = '';
                if (imageUrl && imageUrl.startsWith('http')) {
                  const folder = path.join(process.cwd(), 'assets', 'img', 'posts', datePrefix);
                  const localPath = await downloadImage(imageUrl, folder);
                  if (localPath) {
                    // make relative like ../assets/img/posts/YYYY-MM-DD/filename
                    const rel = path.join('..', path.relative(process.cwd(), localPath)).replace(/\\/g, '/');
                    imageFront = `image: ${rel}\n`;
                  }
                }

                const mdblocks = await n2m.pageToMarkdown(pageId);
                
                // Converter blocos para string: { type, blockId, parent, children }
                let mdString = '';
                
                if (Array.isArray(mdblocks)) {
                  for (const block of mdblocks) {
                    if (typeof block === 'string') {
                      mdString += block + '\n\n';
                    } else if (block && typeof block === 'object') {
                      let blockContent = '';
                      
                      // Estrutura notion-to-md: o conteÃºdo estÃ¡ em 'parent'
                      if (block.parent) {
                        blockContent = String(block.parent);
                      }
                      // Fallback para outras propriedades
                      else if (block.markdown) {
                        blockContent = String(block.markdown);
                      }
                      else if (block.content) {
                        blockContent = String(block.content);
                      }
                      else if (block.children && Array.isArray(block.children)) {
                        const processChildren = (children) => {
                          let content = '';
                          for (const child of children) {
                            if (typeof child === 'string') {
                              content += child + '\n';
                            } else if (child && typeof child === 'object') {
                              if (child.parent) {
                                content += String(child.parent) + '\n';
                              } else if (child.markdown) {
                                content += String(child.markdown) + '\n';
                              } else if (child.children) {
                                content += processChildren(child.children);
                              }
                            }
                          }
                          return content;
                        };
                        blockContent = processChildren(block.children);
                      }
                      
                      if (blockContent && blockContent.trim()) {
                        mdString += blockContent + '\n\n';
                      }
                    } else {
                      mdString += String(block) + '\n\n';
                    }
                  }
                } else if (typeof mdblocks === 'string') {
                  mdString = mdblocks;
                } else {
                  mdString = String(mdblocks);
                }
                
                // Limpeza final
                mdString = mdString.replace(/\[object Object\]/g, '').trim();

                const escTitle = title.replace(/"/g, '\\"').replace(/\n/g, ' ');
                const escInfo = String(info || '').replace(/"/g, '\\"').replace(/\n/g, ' ');

                let frontmatter = `---\nlayout: post\ntitle: "${escTitle}"\n`;
                if (escInfo) frontmatter += `info: ${escInfo}\n`;
                frontmatter += `date: ${datePrefix}\n`;
                if (tech) frontmatter += `tech: "${tech}"\n`;
                frontmatter += `type: post\n`;
                if (imageFront) frontmatter += imageFront;
                if (category) frontmatter += `category: ${category}\n`;
                if (tags.length) frontmatter += `tags: [${tags.join(', ')}]\n`;
                frontmatter += `---\n\n`;

                const fullContent = frontmatter + mdString;
                const fileName = `${datePrefix}-${slug}.md`;
                fs.writeFileSync(path.join(postsDir, fileName), fullContent, 'utf8');
                console.log(`âœ“ Synced: ${fileName}`);
              }

              console.log('Sync completed successfully!');
            } catch (error) {
              console.error('Error syncing posts:', error);
              process.exit(1);
            }
          }

          syncPosts().catch(err => {
            console.error('Fatal error:', err);
            process.exit(1);
          });
          SCRIPT_EOF
      
      - name: Run sync
        env:
          NOTION_TOKEN: ${{ secrets.NOTION_TOKEN }}
          NOTION_DATABASE_ID: ${{ secrets.NOTION_DATABASE_ID }}
        run: node sync-notion.js
      
      - name: Commit and push changes
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add _posts/
          git diff --quiet && git diff --staged --quiet || (git commit -m "ðŸ”„ Sync posts from Notion" && git push)
