name: Sync Notion to Jekyll

on:
  # Roda a cada hora
  schedule:
    - cron: '0 * * * *'
  
  # Permite rodar manualmente
  workflow_dispatch:

jobs:
  sync:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Install dependencies
        run: |
          npm install notion-to-md @notionhq/client dotenv
      
      - name: Create sync script
        run: |
          cat > sync-notion.js << 'SCRIPT_EOF'
          const { Client } = require('@notionhq/client');
          const { NotionToMarkdown } = require('notion-to-md');
          const fs = require('fs');
          const path = require('path');

          const notion = new Client({ auth: process.env.NOTION_TOKEN });
          const n2m = new NotionToMarkdown({ notionClient: notion });

          function sanitizeSlug(text) {
            return String(text || '')
              .toLowerCase()
              .replace(/[^\w\s-]/g, '')
              .replace(/[\s_]+/g, '-')
              .replace(/-+/g, '-')
              .replace(/^-+|-+$/g, '');
          }

          async function downloadImage(url, folder) {
            try {
              await fs.promises.mkdir(folder, { recursive: true });
              const parsed = new URL(url);
              let filename = path.basename(parsed.pathname).split('?')[0];
              if (!filename.includes('.')) filename += '.jpg';
              const filepath = path.join(folder, filename);
              const res = await fetch(url);
              if (!res.ok) throw new Error(`Image download failed ${res.status}`);
              const arrayBuffer = await res.arrayBuffer();
              await fs.promises.writeFile(filepath, Buffer.from(arrayBuffer));
              return filepath;
            } catch (err) {
              console.warn('Failed to download image', err.message || err);
              return null;
            }
          }

          async function queryDatabase(databaseId, body) {
            if (notion.databases && typeof notion.databases.query === 'function') {
              return await notion.databases.query(Object.assign({ database_id: databaseId }, body));
            }
            console.warn('notion.databases.query not available; using fallback fetch to Notion API');
            const url = `https://api.notion.com/v1/databases/${databaseId}/query`;
            const res = await fetch(url, {
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${process.env.NOTION_TOKEN}`,
                'Notion-Version': '2022-06-28',
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(body || {})
            });
            const data = await res.json();
            if (!res.ok) {
              const err = new Error(`Notion API error: ${data.message || res.statusText}`);
              err.response = data;
              throw err;
            }
            return data;
          }

          async function syncPosts() {
            try {
              const filter = {
                filter: {
                  property: 'Published',
                  checkbox: { equals: true }
                }
              };

              const response = await queryDatabase(process.env.NOTION_DATABASE_ID, filter);
              console.log(`Found ${response.results?.length || 0} published posts`);

              const postsDir = path.join(process.cwd(), '_posts');
              if (!fs.existsSync(postsDir)) fs.mkdirSync(postsDir, { recursive: true });

              for (const page of (response.results || [])) {
                const pageId = page.id;
                const title = page.properties?.Title?.title?.[0]?.plain_text || page.properties?.Name?.title?.[0]?.plain_text || 'Untitled';
                let slug = page.properties?.Slug?.rich_text?.[0]?.plain_text || '';
                if (!slug) slug = sanitizeSlug(title);
                const rawDate = page.properties?.Date?.date?.start || new Date().toISOString();
                const datePrefix = rawDate.split('T')[0];
                const tags = page.properties?.Tags?.multi_select?.map(t => t.name) || [];
                const category = page.properties?.Category?.select?.name || '';
                const info = (page.properties?.Info?.rich_text?.[0]?.plain_text) || (page.properties?.Description?.rich_text?.[0]?.plain_text) || '';
                const tech = (page.properties?.Tech?.rich_text?.[0]?.plain_text) || page.properties?.Tech?.select?.name || '';

                // Try to find image: cover > property Image (files/url) > page.properties.Image.url
                let imageUrl = null;
                if (page.cover) imageUrl = page.cover.external?.url || page.cover.file?.url || imageUrl;
                const imgProp = page.properties?.Image;
                if (imgProp) {
                  if (imgProp.type === 'files' && imgProp.files && imgProp.files[0]) {
                    imageUrl = imgProp.files[0].file?.url || imgProp.files[0].external?.url || imageUrl;
                  } else if (imgProp.type === 'url') {
                    imageUrl = imgProp.url || imageUrl;
                  } else if (imgProp.type === 'rich_text') {
                    imageUrl = imgProp.rich_text?.[0]?.plain_text || imageUrl;
                  }
                }

                // Download image if available
                let imageFront = '';
                if (imageUrl && imageUrl.startsWith('http')) {
                  const folder = path.join(process.cwd(), 'assets', 'img', 'posts', datePrefix);
                  const localPath = await downloadImage(imageUrl, folder);
                  if (localPath) {
                    // make relative like ../assets/img/posts/YYYY-MM-DD/filename
                    const rel = path.join('..', path.relative(process.cwd(), localPath)).replace(/\\/g, '/');
                    imageFront = `image: ${rel}\n`;
                  }
                }

                const mdblocks = await n2m.pageToMarkdown(pageId);
                let mdString = n2m.toMarkdownString(mdblocks);
                // Garantir que mdString seja uma string; alguns pacotes podem retornar array/objetos
                if (typeof mdString !== 'string') {
                  if (Array.isArray(mdString)) {
                    mdString = mdString.map(part => (typeof part === 'string' ? part : JSON.stringify(part))).join('\n\n');
                  } else {
                    mdString = String(mdString);
                  }
                }

                // DiagnÃ³stico adicional: se ainda houver '[object Object]', logar uma prÃ©-visualizaÃ§Ã£o dos blocos
                if (mdString.indexOf('[object Object]') !== -1 || typeof mdString !== 'string') {
                  const preview = (arr) => {
                    try {
                      const slice = Array.isArray(arr) ? arr.slice(0,3) : [arr];
                      return JSON.stringify(slice, (k,v)=>{
                        if (typeof v === 'object' && v !== null) {
                          // tentar extrair texto Ãºtil
                          if (v.plain_text) return v.plain_text;
                          if (v.text) return v.text;
                        }
                        return v;
                      }, 2).slice(0,2000);
                    } catch(e){ return String(arr).slice(0,1000); }
                  };
                  console.warn('mdString contains [object Object] or is not string â€” previewing mdblocks:', preview(mdblocks));
                }

                const escTitle = title.replace(/"/g, '\\"').replace(/\n/g, ' ');
                const escInfo = String(info || '').replace(/"/g, '\\"').replace(/\n/g, ' ');

                let frontmatter = `---\nlayout: post\ntitle: "${escTitle}"\n`;
                if (escInfo) frontmatter += `info: ${escInfo}\n`;
                frontmatter += `date: ${datePrefix}\n`;
                if (tech) frontmatter += `tech: "${tech}"\n`;
                frontmatter += `type: post\n`;
                if (imageFront) frontmatter += imageFront;
                if (category) frontmatter += `category: ${category}\n`;
                if (tags.length) frontmatter += `tags: [${tags.join(', ')}]\n`;
                frontmatter += `---\n\n`;

                const fullContent = frontmatter + mdString;
                const fileName = `${datePrefix}-${slug}.md`;
                fs.writeFileSync(path.join(postsDir, fileName), fullContent, 'utf8');
                console.log(`âœ“ Synced: ${fileName}`);
              }

              console.log('Sync completed successfully!');
            } catch (error) {
              console.error('Error syncing posts:', error);
              process.exit(1);
            }
          }

          syncPosts().catch(err => {
            console.error('Fatal error:', err);
            process.exit(1);
          });
          SCRIPT_EOF
      
      - name: Run sync
        env:
          NOTION_TOKEN: ${{ secrets.NOTION_TOKEN }}
          NOTION_DATABASE_ID: ${{ secrets.NOTION_DATABASE_ID }}
        run: node sync-notion.js
      
      - name: Commit and push changes
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add _posts/
          git diff --quiet && git diff --staged --quiet || (git commit -m "ðŸ”„ Sync posts from Notion" && git push)
